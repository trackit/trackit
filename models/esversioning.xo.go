package models

// Code generated by xo. DO NOT EDIT.

// EsVersioning represents a row from 'trackit.es_versioning'.
type EsVersioning struct {
	ID             int    `json:"id"`              // id
	CurrentVersion int    `json:"current_version"` // current_version
	TemplateName   string `json:"template_name"`   // template_name
	IndexName      string `json:"index_name"`      // index_name
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the EsVersioning exists in the database.
func (ev *EsVersioning) Exists() bool {
	return ev._exists
}

// Deleted returns true when the EsVersioning has been marked for deletion from
// the database.
func (ev *EsVersioning) Deleted() bool {
	return ev._deleted
}

// Insert inserts the EsVersioning to the database.
func (ev *EsVersioning) Insert(db DB) error {
	switch {
	case ev._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case ev._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO trackit.es_versioning (` +
		`current_version, template_name, index_name` +
		`) VALUES (` +
		`?, ?, ?` +
		`)`
	// run
	logf(sqlstr, ev.CurrentVersion, ev.TemplateName)
	res, err := db.Exec(sqlstr, ev.CurrentVersion, ev.TemplateName, ev.IndexName)
	if err != nil {
		return err
	}
	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	} // set primary key
	ev.ID = int(id)
	// set exists
	ev._exists = true
	return nil
}

// Update updates a EsVersioning in the database.
func (ev *EsVersioning) Update(db DB) error {
	switch {
	case !ev._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case ev._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE trackit.es_versioning SET ` +
		`current_version = ?, template_name = ? ` +
		`WHERE id = ?, index_name = ?`
	// run
	logf(sqlstr, ev.CurrentVersion, ev.TemplateName, ev.ID, ev.IndexName)
	if _, err := db.Exec(sqlstr, ev.CurrentVersion, ev.TemplateName, ev.ID, ev.IndexName); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the EsVersioning to the database.
func (ev *EsVersioning) Save(db DB) error {
	if ev.Exists() {
		return ev.Update(db)
	}
	return ev.Insert(db)
}

// Upsert performs an upsert for EsVersioning.
func (ev *EsVersioning) Upsert(db DB) error {
	switch {
	case ev._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO trackit.es_versioning (` +
		`id, current_version, template_name, index_name` +
		`) VALUES (` +
		`?, ?, ?, ?` +
		`)` +
		` ON DUPLICATE KEY UPDATE ` +
		`current_version = VALUES(current_version), template_name = VALUES(template_name), index_name = VALUES(index_name)`
	// run
	logf(sqlstr, ev.ID, ev.CurrentVersion, ev.TemplateName, ev.IndexName)
	if _, err := db.Exec(sqlstr, ev.ID, ev.CurrentVersion, ev.TemplateName, ev.IndexName); err != nil {
		return err
	}
	// set exists
	ev._exists = true
	return nil
}

// Delete deletes the EsVersioning from the database.
func (ev *EsVersioning) Delete(db DB) error {
	switch {
	case !ev._exists: // doesn't exist
		return nil
	case ev._deleted: // deleted
		return nil
	}
	// delete with composite primary key
	const sqlstr = `DELETE FROM trackit.es_versioning ` +
		`WHERE id = ? AND index_name = ?`
	// run
	logf(sqlstr, ev.ID, ev.IndexName)
	if _, err := db.Exec(sqlstr, ev.ID, ev.IndexName); err != nil {
		return logerror(err)
	}
	// set deleted
	ev._deleted = true
	return nil
}

// EsVersioningByIDIndexName retrieves a row from 'trackit.es_versioning' as a EsVersioning.
//
// Generated from index 'es_versioning_id_index_name_pkey'.
func EsVersioningByIDIndexName(db DB, id int, indexName string) (*EsVersioning, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, current_version, template_name, index_name ` +
		`FROM trackit.es_versioning ` +
		`WHERE id = ? AND index_name = ?`
	// run
	logf(sqlstr, id, indexName)
	ev := EsVersioning{
		_exists: true,
	}
	if err := db.QueryRow(sqlstr, id, indexName).Scan(&ev.ID, &ev.CurrentVersion, &ev.TemplateName, &ev.IndexName); err != nil {
		return nil, logerror(err)
	}
	return &ev, nil
}
